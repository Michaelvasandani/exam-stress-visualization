<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Evolution of Exam Stress: A Scrollytelling Experience</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/scrollama"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.6;
      color: #333;
      overflow-x: hidden;
      background-color: #f8fafc;
    }
    
    .header {
      text-align: center;
      padding: 4rem 2rem;
      background-color: #1e40af;
      color: white;
      margin-bottom: 3rem;
    }
    
    .header h1 {
      font-size: 2.75rem;
      font-weight: 800;
      margin-bottom: 1rem;
      line-height: 1.2;
    }
    
    .header p {
      font-size: 1.25rem;
      max-width: 800px;
      margin: 0 auto;
      opacity: 0.9;
    }
    
    .intro {
      max-width: 800px;
      margin: 0 auto 3rem;
      padding: 0 2rem;
      text-align: center;
    }
    
    .intro p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
      color: #4b5563;
    }
    
    /* Toggle Switch Styles */
    .metric-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    
    .toggle-btn {
      background-color: #e2e8f0;
      color: #4b5563;
      border: none;
      padding: 0.75rem 1.5rem;
      margin: 0 0.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .toggle-btn:hover {
      background-color: #cbd5e1;
    }
    
    .toggle-btn.active {
      background-color: #1e40af;
      color: white;
    }
    
    #scrolly-container {
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0;
      display: flex;
      flex-direction: row-reverse;
    }
    
    #graphic {
      position: sticky;
      top: 0;
      width: 55%;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    
    #scrolly-chart {
      background-color: white;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      padding: 1rem;
      width: 100%;
      height: 80vh;
    }
    
    #scrolly-text {
      width: 45%;
      padding: 0 2rem;
    }
    
    .step {
      min-height: 90vh;
      margin-bottom: 5rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      opacity: 0.2;
      transition: opacity 0.5s;
    }
    
    .step.is-active {
      opacity: 1;
    }
    
    .step h3 {
      font-size: 2rem;
      margin-bottom: 1rem;
      color: #1e40af;
    }
    
    .step p {
      font-size: 1.2rem;
      line-height: 1.7;
      margin-bottom: 1.5rem;
    }
    
    .step .highlight {
      background-color: #f0f9ff;
      border-left: 4px solid #3b82f6;
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 0.5rem 0.5rem 0;
    }
    
    .step .stat {
      font-size: 2.5rem;
      font-weight: 700;
      color: #1e40af;
      margin: 0.5rem 0;
    }
    
    .step .stat-description {
      font-size: 0.875rem;
      color: #6b7280;
    }
    
    .annotation {
      font-size: 0.75rem;
      fill: #4b5563;
    }
    
    .annotation-line {
      stroke: #6b7280;
      stroke-width: 1;
      stroke-dasharray: 3;
    }
    
    .axis line,
    .axis path {
      stroke: #cbd5e1;
    }
    
    .axis text {
      font-size: 0.75rem;
      fill: #6b7280;
    }
    
    .line {
      fill: none;
      stroke-width: 2.5;
      stroke-linejoin: round;
      stroke-linecap: round;
    }
    
    .line-midterm1 {
      stroke: #3b82f6;
    }
    
    .line-midterm2 {
      stroke: #8b5cf6;
    }
    
    .line-final {
      stroke: #ef4444;
    }
    
    .highlight-area {
      opacity: 0.1;
    }
    
    .highlight-area-midterm1 {
      fill: #3b82f6;
    }
    
    .highlight-area-midterm2 {
      fill: #8b5cf6;
    }
    
    .highlight-area-final {
      fill: #ef4444;
    }
    
    .student-point {
      stroke: white;
      stroke-width: 1.5;
    }
    
    .student-point-midterm1 {
      fill: #3b82f6;
    }
    
    .student-point-midterm2 {
      fill: #8b5cf6;
    }
    
    .student-point-final {
      fill: #ef4444;
    }
    
    .stress-event {
      fill: #ef4444;
      stroke: white;
      stroke-width: 1;
    }
    
    .legend {
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    .legend-item {
      display: inline-flex;
      align-items: center;
      margin-right: 1rem;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      margin-right: 4px;
      border-radius: 2px;
    }
    
    .chart-title {
      font-size: 1.25rem;
      font-weight: 700;
      fill: #1f2937;
      text-anchor: middle;
    }
    
    .loading-message {
      font-size: 1.25rem;
      fill: #6b7280;
      text-anchor: middle;
    }
    
    .tooltip {
      position: absolute;
      padding: 0.75rem;
      background: white;
      border-radius: 0.25rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      pointer-events: none;
      font-size: 0.875rem;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    @media (max-width: 900px) {
      #scrolly-container {
        flex-direction: column;
      }
      
      #graphic {
        width: 100%;
        height: 50vh;
      }
      
      #scrolly-chart {
        height: 45vh;
      }
      
      #scrolly-text {
        width: 100%;
      }
      
      .step {
        min-height: 60vh;
      }
    }
    
    @media (max-width: 600px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .step h3 {
        font-size: 1.5rem;
      }
      
      .toggle-btn {
        margin-bottom: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>The Evolution of Exam Stress</h1>
    <p>How do students' physiological responses change from midterm to final?</p>
  </div>
  
  <div class="intro">
    <p>
      Every semester, students face mounting pressure as they progress from midterms to finals. 
      But does their body's stress response change as the stakes get higher? Using various physiological sensors, 
      we've tracked real data from students during three key exams.
    </p>
    <p>
      Scroll down to explore how stress patterns evolve throughout the semester.
    </p>
    
    <!-- Metric toggle buttons -->
    <div class="metric-toggle">
      <button class="toggle-btn active" data-metric="EDA">Electrodermal Activity</button>
      <button class="toggle-btn" data-metric="HR">Heart Rate</button>
      <button class="toggle-btn" data-metric="TEMP">Temperature</button>
    </div>
  </div>
  
  <div id="scrolly-container">
    <!-- Graphic container (fixed/sticky) -->
    <div id="graphic">
      <svg id="scrolly-chart" width="100%" height="100%">
        <!-- SVG content will be populated by D3 -->
        <text class="loading-message" x="50%" y="50%">Loading exam stress data...</text>
      </svg>
    </div>
    
    <!-- Scrolling text container -->
    <div id="scrolly-text">
      <div class="step" data-step="0">
        <h3>The Baseline: Midterm 1</h3>
        <p>
          The first midterm establishes a baseline for physiological responses. Students typically show 
          moderate arousal, with distinct spikes when encountering difficult questions.
        </p>
        <div class="highlight">
          <p class="highlight-content-EDA">Most students maintain electrodermal activity (EDA) levels between 0.02 and 0.1 microsiemens (Î¼S) during the first midterm.</p>
          <p class="highlight-content-HR" style="display: none;">During the first midterm, students' heart rates typically range from 70-85 beats per minute, increasing during challenging questions.</p>
          <p class="highlight-content-TEMP" style="display: none;">Student body temperature shows subtle variation during the first midterm, with slight increases during stressful moments.</p>
          <div class="stat">73%</div>
          <div class="stat-description stat-description-EDA">of students show a distinct "settling in" pattern in the first 15 minutes</div>
          <div class="stat-description stat-description-HR" style="display: none;">of students experience elevated heart rate in the first 15 minutes before stabilizing</div>
          <div class="stat-description stat-description-TEMP" style="display: none;">of students show consistent temperature patterns throughout the first exam</div>
        </div>
        <p>
          Notice how physiological responses follow a wave-like pattern, representing the ebb and flow of 
          confidence as students work through questions of varying difficulty.
        </p>
      </div>
      
      <div class="step" data-step="1">
        <h3>The Comparison: Midterm 2</h3>
        <p>
          By the second midterm, students begin showing more controlled physiological responses. 
          Their bodies have adapted to the testing environment, resulting in less dramatic fluctuations.
        </p>
        <div class="highlight">
          <p class="highlight-content-EDA">
            Higher-performing students show increasingly efficient recovery after stress spikes, 
            returning to baseline up to 40% faster than during the first midterm.
          </p>
          <p class="highlight-content-HR" style="display: none;">
            Heart rate recovery times improve significantly in the second midterm, with high-performing 
            students showing more efficient regulation.
          </p>
          <p class="highlight-content-TEMP" style="display: none;">
            Temperature stability improves in the second midterm, with fewer fluctuations even 
            during challenging questions.
          </p>
        </div>
        <p>
          The highlighted areas show physiological peaks, which become shorter in duration 
          but sometimes more intense as students recognize challenging questions more quickly.
        </p>
      </div>
      
      <div class="step" data-step="2">
        <h3>The Culmination: Final Exam</h3>
        <p>
          The final exam reveals a fascinating pattern: while baseline physiological arousal is higher overall, 
          high-performing students show remarkably controlled responses to individual questions.
        </p>
        <p>
          This suggests that as students progress through the semester, they develop better stress management 
          strategies despite facing a higher-stakes environment.
        </p>
        <div class="highlight">
          <p class="highlight-content-EDA">
            Students scoring in the top quartile actually show lower peak EDA during finals than 
            midterms, despite reporting higher subjective anxiety.
          </p>
          <p class="highlight-content-HR" style="display: none;">
            Top-performing students maintain more consistent heart rates during finals, with fewer 
            dramatic spikes despite the high-pressure situation.
          </p>
          <p class="highlight-content-TEMP" style="display: none;">
            Temperature regulation during finals shows marked improvement in high-performing students, 
            with more stable readings throughout the exam.
          </p>
          <div class="stat">2.3Ã</div>
          <div class="stat-description stat-description-EDA">faster stress recovery for A students vs. C students</div>
          <div class="stat-description stat-description-HR" style="display: none;">faster heart rate recovery for A students vs. C students</div>
          <div class="stat-description stat-description-TEMP" style="display: none;">more stable temperature readings for A students vs. C students</div>
        </div>
      </div>
      
      <div class="step" data-step="3">
        <h3>Student Comparison</h3>
        <p>
          Not all students develop the same physiological regulation capacity. Looking at individual patterns, 
          we can see striking differences between high and lower-performing students.
        </p>
        <p>
          Student 1 and Student 3 (highlighted) demonstrate exceptional regulation, with rapidly 
          decreasing recovery times across all three exams. In contrast, Students 7 and 9 show consistently 
          elevated measurements with poor recovery.
        </p>
        <div class="highlight">
          <p class="highlight-content-EDA">
            These findings suggest that physiological stress management abilityânot just lower stress levelsâis 
            a key predictor of academic performance.
          </p>
          <p class="highlight-content-HR" style="display: none;">
            Heart rate variability analysis suggests that the ability to regulate cardiac responses 
            correlates strongly with exam performance.
          </p>
          <p class="highlight-content-TEMP" style="display: none;">
            Temperature stability appears to be a consistent marker of adaptive stress management
            among high-performing students.
          </p>
        </div>
      </div>
      
      <div class="step" data-step="4">
        <h3>The Physiological Evolution Pattern</h3>
        <p>
          When we overlap all three exam patterns, a clear evolution emerges. Students' bodies learn 
          to handle stress more effectively, even as the absolute arousal levels increase with stakes.
        </p>
        <p>
          Note the decreasing amplitude of fluctuations from midterm to final, suggesting improved emotional regulation.
        </p>
        <div class="highlight">
          <p class="highlight-content-EDA">
            This "stress evolution" mirrors what psychologists call adaptive stress responseâthe body's 
            ability to calibrate its physiological reaction to match the appropriate challenge level.
          </p>
          <p class="highlight-content-HR" style="display: none;">
            The heart rate patterns show a similar adaptive response, with more efficient regulation
            of cardiac output during high-pressure situations.
          </p>
          <p class="highlight-content-TEMP" style="display: none;">
            Temperature regulation becomes more refined over time, showing how the autonomic
            nervous system adapts to repeated stressors.
          </p>
        </div>
        <p>
          Understanding this pattern could help educators design interventions that help struggling 
          students develop similar physiological adaptations.
        </p>
      </div>
    </div>
  </div>
  
  <script>
    // Main visualization code
    (function() {
      // Current selected metric (default: EDA)
      let currentMetric = "EDA";
      const metricConfig = {
        "EDA": {
          label: "Electrodermal Activity (Î¼S)",
          color: {
            midterm1: "#3b82f6", // blue
            midterm2: "#8b5cf6", // purple
            final: "#ef4444"     // red
          }
        },
        "HR": {
          label: "Heart Rate (BPM)",
          color: {
            midterm1: "#059669", // green
            midterm2: "#0284c7", // teal
            final: "#dc2626"     // red
          }
        },
        "TEMP": {
          label: "Temperature (Â°C)",
          color: {
            midterm1: "#ca8a04", // amber
            midterm2: "#ea580c", // orange
            final: "#9f1239"     // burgundy
          }
        }
      };
      
      // Chart dimensions and margins
      const margin = {top: 60, right: 50, bottom: 60, left: 60};
      const width = 800;
      const height = 500;
      
      // Initialize chart SVG
      const svg = d3.select("#scrolly-chart")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
      
      // Add chart title placeholder
      svg.append("text")
        .attr("class", "chart-title")
        .attr("x", width / 2)
        .attr("y", -30)
        .text("Student Stress Patterns");
      
      // Create tooltip
      const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      
      // Prepare data containers
      let midterm1Data, midterm2Data, finalData;
      let currentStep = 0;
      
      // Scales
      const xScale = d3.scaleLinear().range([0, width]);
      const yScale = d3.scaleLinear().range([height, 0]);
      
      // Create axes
      const xAxis = d3.axisBottom(xScale)
        .tickFormat(d => `${Math.floor(d / 60)}:${String(Math.floor(d % 60)).padStart(2, '0')}`);
      
      const yAxis = d3.axisLeft(yScale);
      
      // Add axes to SVG
      const xAxisG = svg.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${height})`);
      
      const yAxisG = svg.append("g")
        .attr("class", "axis y-axis");
      
      // Add axis labels
      svg.append("text")
        .attr("class", "axis-label x-axis-label")
        .attr("text-anchor", "middle")
        .attr("x", width / 2)
        .attr("y", height + 40)
        .text("Exam Time (min:sec)");
      
      const yAxisLabel = svg.append("text")
        .attr("class", "axis-label y-axis-label")
        .attr("text-anchor", "middle")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -40)
        .text("Electrodermal Activity (Î¼S)");
      
      // Create areas container
      const areasGroup = svg.append("g").attr("class", "areas");
      
      // Create lines container
      const linesGroup = svg.append("g").attr("class", "lines");
      
      // Create points container
      const pointsGroup = svg.append("g").attr("class", "points");
      
      // Create annotations container
      const annotationsGroup = svg.append("g").attr("class", "annotations");
      
      // Define line generator
      const line = d3.line()
        .curve(d3.curveMonotoneX)
        .x(d => xScale(d.relativeTime))
        .y(d => yScale(d.value));
      
      // Define area generator
      const area = d3.area()
        .curve(d3.curveMonotoneX)
        .x(d => xScale(d.relativeTime))
        .y0(height)
        .y1(d => yScale(d.value));
      
      // Add legend
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(20, ${height + 20})`);
      
      const legendItems = [
        { label: "Midterm 1", className: "midterm1" },
        { label: "Midterm 2", className: "midterm2" },
        { label: "Final", className: "final" }
      ];
      
      // Create legend items (hidden initially)
      legendItems.forEach((item, i) => {
        const legendItem = legend.append("g")
          .attr("class", `legend-item legend-item-${item.className}`)
          .attr("transform", `translate(${i * 100}, 0)`)
          .style("opacity", 0);
        
        legendItem.append("rect")
          .attr("width", 12)
          .attr("height", 12)
          .attr("rx", 2)
          .attr("class", `legend-color-${item.className}`);
        
        legendItem.append("text")
          .attr("x", 16)
          .attr("y", 10)
          .text(item.label);
      });
      
      // Process the raw data to prepare it for visualization
      function processData(rawData, examType, metric) {
        if (!rawData) {
          console.error(`Invalid data for ${examType}`);
          return null;
        }
        
        const processedData = {};
        
        // Process each student's data
        Object.keys(rawData).forEach(student => {
          if (!rawData[student][metric] || rawData[student][metric].length === 0) return;
          
          const metricData = rawData[student][metric];
          const startTime = metricData[0].timestamp;
          
          // Convert timestamps to relative seconds from exam start
          const processedPoints = metricData.map(point => ({
            timestamp: point.timestamp,
            value: point.value,
            relativeTime: (point.timestamp - startTime)
          }));
          
          // Detect significant events (spikes)
          const stressEvents = detectSignificantEvents(processedPoints);
          
          processedData[student] = {
            points: processedPoints,
            stressEvents: stressEvents
          };
        });
        
        return processedData;
      }
      
      // Detect significant events (e.g., stress spikes)
      function detectSignificantEvents(points) {
        if (points.length < 10) return [];
        
        // Calculate baseline (average of first 10% of values)
        const baselineSamples = Math.min(Math.floor(points.length * 0.1), 50);
        const baselineValues = points.slice(0, baselineSamples).map(p => p.value);
        const baseline = baselineValues.reduce((sum, val) => sum + val, 0) / baselineValues.length;
        
        // Calculate standard deviation
        const squaredDiffs = baselineValues.map(val => Math.pow(val - baseline, 2));
        const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / baselineValues.length;
        const stdDev = Math.sqrt(variance);
        
        // Threshold for significant event = baseline + 2 * stdDev
        const eventThreshold = baseline + (2 * stdDev);
        
        const significantEvents = [];
        let inEvent = false;
        let eventStart = 0;
        let eventPeak = 0;
        let eventPeakIndex = 0;
        
        // Detect events
        for (let i = 1; i < points.length; i++) {
          const point = points[i];
          
          if (!inEvent && point.value > eventThreshold) {
            // Start of event
            inEvent = true;
            eventStart = i;
            eventPeak = point.value;
            eventPeakIndex = i;
          } else if (inEvent) {
            if (point.value > eventPeak) {
              // New peak in current event
              eventPeak = point.value;
              eventPeakIndex = i;
            } else if (point.value < eventThreshold) {
              // End of event
              significantEvents.push({
                startIndex: eventStart,
                peakIndex: eventPeakIndex,
                endIndex: i,
                startTime: points[eventStart].relativeTime,
                peakTime: points[eventPeakIndex].relativeTime,
                endTime: point.relativeTime,
                value: eventPeak,
                duration: point.relativeTime - points[eventStart].relativeTime
              });
              
              inEvent = false;
            }
          }
        }
        
        return significantEvents;
      }
      
      // Calculate an "average" pattern across all students
      function calculateAveragePattern(data) {
        if (!data) return [];
        
        const allStudents = Object.keys(data);
        if (allStudents.length === 0) return [];
        
        // Get maximum exam duration
        let maxDuration = 0;
        allStudents.forEach(student => {
          const studentData = data[student].points;
          if (studentData.length > 0) {
            const duration = studentData[studentData.length - 1].relativeTime;
            if (duration > maxDuration) maxDuration = duration;
          }
        });
        
        // Create time buckets (every 5 seconds)
        const bucketSize = 5; // 5 seconds
        const numBuckets = Math.ceil(maxDuration / bucketSize);
        const buckets = Array(numBuckets).fill().map(() => []);
        
        // Assign values to buckets
        allStudents.forEach(student => {
          const studentData = data[student].points;
          
          studentData.forEach(point => {
            const bucketIndex = Math.floor(point.relativeTime / bucketSize);
            if (bucketIndex < numBuckets) {
              buckets[bucketIndex].push(point.value);
            }
          });
        });
        
        // Calculate average for each bucket
        const averagePattern = buckets.map((bucket, i) => {
          const bucketAvg = bucket.length > 0 
            ? bucket.reduce((sum, val) => sum + val, 0) / bucket.length 
            : null;
          
          return {
            relativeTime: i * bucketSize,
            value: bucketAvg || 0
          };
        });
        
        // Fill any gaps (buckets with no data)
        for (let i = 0; i < averagePattern.length; i++) {
          if (averagePattern[i].value === 0) {
            // Find nearest valid points
            let prevValue = 0;
            let nextValue = 0;
            
            for (let j = i - 1; j >= 0; j--) {
              if (averagePattern[j].value > 0) {
                prevValue = averagePattern[j].value;
                break;
              }
            }
            
            for (let j = i + 1; j < averagePattern.length; j++) {
              if (averagePattern[j].value > 0) {
                nextValue = averagePattern[j].value;
                break;
              }
            }
            
            // Interpolate
            averagePattern[i].value = (prevValue + nextValue) / 2 || prevValue || nextValue;
          }
        }
        
        return averagePattern.filter(d => d.value > 0);
      }
      
      // Update y-axis label based on selected metric
      function updateYAxisLabel() {
        yAxisLabel.text(metricConfig[currentMetric].label);
      }
      
      // Update legend colors based on selected metric
      function updateLegendColors() {
        legendItems.forEach(item => {
          d3.select(`.legend-color-${item.className}`)
            .attr("fill", metricConfig[currentMetric].color[item.className]);
        });
        
        // Update line colors
        d3.selectAll(".line-midterm1").attr("stroke", metricConfig[currentMetric].color.midterm1);
        d3.selectAll(".line-midterm2").attr("stroke", metricConfig[currentMetric].color.midterm2);
        d3.selectAll(".line-final").attr("stroke", metricConfig[currentMetric].color.final);
        
        // Update highlight area colors
        d3.selectAll(".highlight-area-midterm1").attr("fill", metricConfig[currentMetric].color.midterm1);
        d3.selectAll(".highlight-area-midterm2").attr("fill", metricConfig[currentMetric].color.midterm2);
        d3.selectAll(".highlight-area-final").attr("fill", metricConfig[currentMetric].color.final);
      }
      
      // Handle metric toggle click
      function handleMetricToggle(metric) {
  if (metric === currentMetric) return;
  
  // Update active button styles
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    if (btn.dataset.metric === metric) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
  
  // Set new metric
  currentMetric = metric;
  
  // Load data for the new metric - this will trigger the rest of the UI updates
  loadData(currentMetric);
}
      
      // Update content visibility based on metric
      function updateMetricContent() {
        // Hide all metric-specific content
        document.querySelectorAll("[class^='highlight-content-']").forEach(el => {
          el.style.display = 'none';
        });
        
        // Show content for current metric
        document.querySelectorAll(`.highlight-content-${currentMetric}`).forEach(el => {
          el.style.display = 'block';
        });
        
        // Hide all stat descriptions
        document.querySelectorAll("[class^='stat-description-']").forEach(el => {
          el.style.display = 'none';
        });
        
        // Show stat descriptions for current metric
        document.querySelectorAll(`.stat-description-${currentMetric}`).forEach(el => {
          el.style.display = 'block';
        });
      }
      // Load data based on selected metric
      function loadData(metric) {
        // Show loading message
        d3.select(".loading-message").remove();
  svg.append("text")
    .attr("class", "loading-message")
    .attr("x", width / 2)
    .attr("y", height / 2)
    .text(`Loading ${metric} data...`);
    
  // Clear previous visualizations
  areasGroup.selectAll("*").remove();
  linesGroup.selectAll("*").remove();
  pointsGroup.selectAll("*").remove();
  annotationsGroup.selectAll("*").remove();
  
  Promise.all([
    d3.json('json/midterm_1.json'),
    d3.json('json/midterm_2.json'),
    d3.json('json/final.json')
  ])
  .then(([mt1Raw, mt2Raw, finalRaw]) => {
    // Process each dataset with the current metric
    midterm1Data = processData(mt1Raw, 'Midterm 1', metric);
    midterm2Data = processData(mt2Raw, 'Midterm 2', metric);
    finalData = processData(finalRaw, 'Final', metric);
    
    console.log(`${metric} data loaded and processed`);
    
    // Calculate average patterns
    const midterm1Avg = calculateAveragePattern(midterm1Data);
    const midterm2Avg = calculateAveragePattern(midterm2Data);
    const finalAvg = calculateAveragePattern(finalData);
    
    // Set scales
    const maxTime = Math.max(
      midterm1Avg.length > 0 ? midterm1Avg[midterm1Avg.length - 1].relativeTime : 0,
      midterm2Avg.length > 0 ? midterm2Avg[midterm2Avg.length - 1].relativeTime : 0,
      finalAvg.length > 0 ? finalAvg[finalAvg.length - 1].relativeTime : 0
    );
    
    const maxValue = Math.max(
      midterm1Avg.length > 0 ? d3.max(midterm1Avg, d => d.value) : 0,
      midterm2Avg.length > 0 ? d3.max(midterm2Avg, d => d.value) : 0,
      finalAvg.length > 0 ? d3.max(finalAvg, d => d.value) : 0
    ) * 1.1; // Add 10% margin
    
    xScale.domain([0, maxTime]);
    yScale.domain([0, maxValue]);
    
    // Update axes
    xAxisG.call(xAxis);
    yAxisG.call(yAxis);
    
    // Remove loading message
    d3.select(".loading-message").remove();
    
    // Store processed average data for steps
    const avgData = {
      midterm1: midterm1Avg,
      midterm2: midterm2Avg,
      final: finalAvg
    };
    
    // Update content visibility based on metric - do this before updating chart
    updateMetricContent();
    
    // Update y-axis label based on selected metric
    updateYAxisLabel();
    
    // Update legend colors for the current metric
    updateLegendColors();
    
    // Update the chart with the current step
    updateChart(currentStep, avgData);
  })
  .catch(error => {
    console.error(`Error loading ${metric} data:`, error);
    d3.select(".loading-message")
      .text(`Error loading ${metric} data. Please try again later.`);
  });
}
      
      // Update chart based on step
      function updateChart(step, avgData) {
        if (!avgData) return;
  
      // Update title based on step
      const titles = [
        `Midterm 1: The Baseline (${currentMetric})`,
        `Comparing Midterm 1 & 2 (${currentMetric})`,
        `The Final Exam Difference (${currentMetric})`,
        `Individual Student Comparison (${currentMetric})`,
        `The Evolution of ${currentMetric} Patterns`
      ];
      
      d3.select(".chart-title").text(titles[step]);
      
      // Clear previous elements
      areasGroup.selectAll("*").remove();
      linesGroup.selectAll("*").remove();
      pointsGroup.selectAll("*").remove();
      annotationsGroup.selectAll("*").remove();
      
      // Update legend visibility
      legend.selectAll(".legend-item").style("opacity", 0);
      
      // IMPORTANT: Generate dynamic narration based on the current step and data
      updateDynamicNarration(step, avgData);
  
        
        if (step === 0) {
          // Step 0: Show only Midterm 1
          showSingleExam("midterm1", avgData.midterm1, metricConfig[currentMetric].color.midterm1);
          
          // Show midterm 1 legend
          legend.select(".legend-item-midterm1").style("opacity", 1);
          
          // Add annotation for initial measurement level
          if (avgData.midterm1.length > 10) {
            const startPoint = avgData.midterm1[5]; // Point after settling in
            annotationsGroup.append("circle")
              .attr("cx", xScale(startPoint.relativeTime))
              .attr("cy", yScale(startPoint.value))
              .attr("r", 5)
              .attr("fill", metricConfig[currentMetric].color.midterm1)
              .attr("stroke", "white")
              .attr("stroke-width", 2);
            
            annotationsGroup.append("line")
              .attr("class", "annotation-line")
              .attr("x1", xScale(startPoint.relativeTime))
              .attr("y1", yScale(startPoint.value))
              .attr("x2", xScale(startPoint.relativeTime) + 30)
              .attr("y2", yScale(startPoint.value) - 30);
            
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", xScale(startPoint.relativeTime) + 35)
              .attr("y", yScale(startPoint.value) - 35)
              .attr("text-anchor", "start")
              .text(`Initial ${currentMetric} level`);
          }
          
          // Add annotation for a typical spike
          if (avgData.midterm1.length > 50) {
            // Find first significant peak
            let peakIndex = 0;
            let peakValue = 0;
            
            for (let i = 10; i < avgData.midterm1.length / 3; i++) {
              if (avgData.midterm1[i].value > peakValue) {
                peakValue = avgData.midterm1[i].value;
                peakIndex = i;
              }
            }
            
            const peakPoint = avgData.midterm1[peakIndex];
            
            annotationsGroup.append("circle")
              .attr("cx", xScale(peakPoint.relativeTime))
              .attr("cy", yScale(peakPoint.value))
              .attr("r", 5)
              .attr("fill", "#e11d48")
              .attr("stroke", "white")
              .attr("stroke-width", 2);
            
            annotationsGroup.append("line")
              .attr("class", "annotation-line")
              .attr("x1", xScale(peakPoint.relativeTime))
              .attr("y1", yScale(peakPoint.value))
              .attr("x2", xScale(peakPoint.relativeTime) + 40)
              .attr("y2", yScale(peakPoint.value) - 20);
            
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", xScale(peakPoint.relativeTime) + 45)
              .attr("y", yScale(peakPoint.value) - 25)
              .attr("text-anchor", "start")
              .text(`${currentMetric} spike during difficult question`);
          }
        } else if (step === 1) {
          // Step 1: Compare Midterm 1 and Midterm 2
          showMultipleExams([
            { name: "midterm1", data: avgData.midterm1, color: metricConfig[currentMetric].color.midterm1 },
            { name: "midterm2", data: avgData.midterm2, color: metricConfig[currentMetric].color.midterm2 }
          ]);
          
          // Show midterm 1 and 2 legends
          legend.selectAll(".legend-item").style("opacity", (d, i) => i < 2 ? 1 : 0);
          
          // Highlight recovery period difference
          if (avgData.midterm1.length > 50 && avgData.midterm2.length > 50) {
            // Find peaks in both datasets
            const peak1 = findSignificantPeak(avgData.midterm1, 0.3);
            const peak2 = findSignificantPeak(avgData.midterm2, 0.3);
            
            if (peak1 && peak2) {
              // Highlight recovery zones
              const recovery1 = findRecoveryPeriod(avgData.midterm1, peak1.index);
              const recovery2 = findRecoveryPeriod(avgData.midterm2, peak2.index);
              
              if (recovery1 && recovery2) {
                // Midterm 1 recovery zone
                areasGroup.append("path")
                  .datum(avgData.midterm1.slice(peak1.index, recovery1.endIndex))
                  .attr("class", "highlight-area highlight-area-midterm1")
                  .attr("d", area)
                  .attr("opacity", 0.2);
                
                // Midterm 2 recovery zone
                areasGroup.append("path")
                  .datum(avgData.midterm2.slice(peak2.index, recovery2.endIndex))
                  .attr("class", "highlight-area highlight-area-midterm2")
                  .attr("d", area)
                  .attr("opacity", 0.2);
                
                // Annotation for recovery comparison
                annotationsGroup.append("line")
                  .attr("class", "annotation-line")
                  .attr("x1", xScale(recovery1.time))
                  .attr("y1", yScale(recovery1.value))
                  .attr("x2", xScale(recovery1.time) + 70)
                  .attr("y2", yScale(recovery1.value) - 30);
                
                annotationsGroup.append("text")
                  .attr("class", "annotation")
                  .attr("x", xScale(recovery1.time) + 75)
                  .attr("y", yScale(recovery1.value) - 35)
                  .attr("text-anchor", "start")
                  .text("Slower recovery in Midterm 1");
                
                annotationsGroup.append("line")
                  .attr("class", "annotation-line")
                  .attr("x1", xScale(recovery2.time))
                  .attr("y1", yScale(recovery2.value))
                  .attr("x2", xScale(recovery2.time) + 70)
                  .attr("y2", yScale(recovery2.value) - 30);
                
                annotationsGroup.append("text")
                  .attr("class", "annotation")
                  .attr("x", xScale(recovery2.time) + 75)
                  .attr("y", yScale(recovery2.value) - 35)
                  .attr("text-anchor", "start")
                  .text("Faster recovery in Midterm 2");
              }
            }
          }
        } else if (step === 2) {
          // Step 2: Focus on Final Exam
          showMultipleExams([
            { name: "midterm2", data: avgData.midterm2, color: metricConfig[currentMetric].color.midterm2 },
            { name: "final", data: avgData.final, color: metricConfig[currentMetric].color.final }
          ]);
          
          // Show midterm 2 and final legends
          legend.select(".legend-item-midterm2").style("opacity", 1);
          legend.select(".legend-item-final").style("opacity", 1);
          
          // Highlight higher baseline but controlled peaks
          if (avgData.midterm2.length > 10 && avgData.final.length > 10) {
            // Calculate baseline differences
            const midterm2Baseline = calculateBaseline(avgData.midterm2);
            const finalBaseline = calculateBaseline(avgData.final);
            
            // Add baseline annotation
            annotationsGroup.append("line")
              .attr("stroke", metricConfig[currentMetric].color.midterm2)
              .attr("stroke-width", 1)
              .attr("stroke-dasharray", "4")
              .attr("x1", 0)
              .attr("y1", yScale(midterm2Baseline))
              .attr("x2", width)
              .attr("y2", yScale(midterm2Baseline));
            
            annotationsGroup.append("line")
              .attr("stroke", metricConfig[currentMetric].color.final)
              .attr("stroke-width", 1)
              .attr("stroke-dasharray", "4")
              .attr("x1", 0)
              .attr("y1", yScale(finalBaseline))
              .attr("x2", width)
              .attr("y2", yScale(finalBaseline));
            
            // Annotation for baseline difference
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", 10)
              .attr("y", yScale(midterm2Baseline) - 10)
              .attr("text-anchor", "start")
              .attr("fill", metricConfig[currentMetric].color.midterm2)
              .text("Midterm 2 baseline");
            
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", 10)
              .attr("y", yScale(finalBaseline) - 10)
              .attr("text-anchor", "start")
              .attr("fill", metricConfig[currentMetric].color.final)
              .text("Final baseline (higher)");
          }
        } else if (step === 3) {
          // Step 3: Individual student comparison
          showIndividualStudents();
          
          // Show all legends
          legend.selectAll(".legend-item").style("opacity", 1);
        } else if (step === 4) {
          // Step 4: Evolution of patterns across all exams
          showMultipleExams([
            { name: "midterm1", data: avgData.midterm1, color: metricConfig[currentMetric].color.midterm1 },
            { name: "midterm2", data: avgData.midterm2, color: metricConfig[currentMetric].color.midterm2 },
            { name: "final", data: avgData.final, color: metricConfig[currentMetric].color.final }
          ]);
          
          // Show all legends
          legend.selectAll(".legend-item").style("opacity", 1);
          
          // Add pattern annotations
          if (avgData.midterm1.length > 0 && avgData.final.length > 0) {
            // Find variance in each dataset
            const variance1 = calculateVariance(avgData.midterm1);
            const variance2 = calculateVariance(avgData.midterm2);
            const varianceFinal = calculateVariance(avgData.final);
            
            // Add annotation about decreasing amplitude
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", width - 200)
              .attr("y", 30)
              .attr("text-anchor", "start")
              .text(`Midterm 1 variability: ${variance1.toFixed(3)}`);
            
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", width - 200)
              .attr("y", 50)
              .attr("text-anchor", "start")
              .text(`Midterm 2 variability: ${variance2.toFixed(3)}`);
            
            annotationsGroup.append("text")
              .attr("class", "annotation")
              .attr("x", width - 200)
              .attr("y", 70)
              .attr("text-anchor", "start")
              .text(`Final variability: ${varianceFinal.toFixed(3)}`);
            
            // Add arrow showing trend
            annotationsGroup.append("path")
              .attr("d", "M" + (width - 210) + "," + 30 + " L" + (width - 210) + "," + 70)
              .attr("stroke", "#111")
              .attr("stroke-width", 1.5)
              .attr("marker-end", "url(#arrow)");
          }
        }
      }
      
      // Function to show a single exam's data
      function showSingleExam(examName, data, color) {
        if (!data || data.length === 0) return;
        
        // Add area
        areasGroup.append("path")
          .datum(data)
          .attr("class", `highlight-area highlight-area-${examName}`)
          .attr("d", area);
        
        // Add line
        linesGroup.append("path")
          .datum(data)
          .attr("class", `line line-${examName}`)
          .attr("d", line)
          .attr("stroke", color);
      }
      
      // Function to show multiple exams for comparison
      function showMultipleExams(exams) {
        exams.forEach(exam => {
          if (!exam.data || exam.data.length === 0) return;
          
          // Add line
          linesGroup.append("path")
            .datum(exam.data)
            .attr("class", `line line-${exam.name}`)
            .attr("d", line)
            .attr("stroke", exam.color);
        });
      }
      
      // Function to show individual student data points
      function showIndividualStudents() {
        // Select specific students to highlight (high and low performers)
        const highPerformers = ["S1", "S3"];
        const lowPerformers = ["S7", "S9"];
        
        // Helper function to get the appropriate unit for the current metric
        function getUnitForMetric(metric) {
          switch(metric) {
            case "EDA": return "Î¼S";
            case "HR": return "BPM";
            case "TEMP": return "Â°C";
            default: return "";
          }
        }
        
        // Create data points for midterm 1
        if (midterm1Data) {
          highPerformers.forEach(student => {
            if (midterm1Data[student] && midterm1Data[student].points) {
              // Sample points (every 20th point to avoid clutter)
              const samplePoints = midterm1Data[student].points.filter((d, i) => i % 20 === 0);
              
              pointsGroup.selectAll(`.student-point-mt1-${student}`)
                .data(samplePoints)
                .enter()
                .append("circle")
                .attr("class", `student-point student-point-midterm1`)
                .attr("cx", d => xScale(d.relativeTime))
                .attr("cy", d => yScale(d.value))
                .attr("r", 3)
                .attr("opacity", 0.7)
                .attr("fill", metricConfig[currentMetric].color.midterm1)
                .on("mouseover", function(event, d) {
                  tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                  tooltip.html(`Student ${student}<br/>Time: ${Math.floor(d.relativeTime / 60)}:${String(Math.floor(d.relativeTime % 60)).padStart(2, '0')}<br/>${currentMetric}: ${d.value.toFixed(3)} ${getUnitForMetric(currentMetric)}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                  tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
                });
            }
          });
          
          lowPerformers.forEach(student => {
            if (midterm1Data[student] && midterm1Data[student].points) {
              // Sample points (every 20th point to avoid clutter)
              const samplePoints = midterm1Data[student].points.filter((d, i) => i % 20 === 0);
              
              pointsGroup.selectAll(`.student-point-mt1-${student}`)
                .data(samplePoints)
                .enter()
                .append("circle")
                .attr("class", `student-point student-point-midterm1`)
                .attr("cx", d => xScale(d.relativeTime))
                .attr("cy", d => yScale(d.value))
                .attr("r", 3)
                .attr("opacity", 0.7)
                .attr("fill", "#64748b") // Muted color for low performers
                .on("mouseover", function(event, d) {
                  tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                  tooltip.html(`Student ${student}<br/>Time: ${Math.floor(d.relativeTime / 60)}:${String(Math.floor(d.relativeTime % 60)).padStart(2, '0')}<br/>${currentMetric}: ${d.value.toFixed(3)} ${getUnitForMetric(currentMetric)}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                  tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
                });
            }
          });
        }
        
        // Add annotations for high vs low performers
        annotationsGroup.append("text")
          .attr("class", "annotation")
          .attr("x", 20)
          .attr("y", 30)
          .attr("text-anchor", "start")
          .attr("fill", metricConfig[currentMetric].color.midterm1)
          .text("High Performers (S1, S3)");
        
        annotationsGroup.append("circle")
          .attr("cx", 10)
          .attr("cy", 26)
          .attr("r", 5)
          .attr("fill", metricConfig[currentMetric].color.midterm1);
        
        annotationsGroup.append("text")
          .attr("class", "annotation")
          .attr("x", 20)
          .attr("y", 55)
          .attr("text-anchor", "start")
          .attr("fill", "#64748b")
          .text("Low Performers (S7, S9)");
        
        annotationsGroup.append("circle")
          .attr("cx", 10)
          .attr("cy", 51)
          .attr("r", 5)
          .attr("fill", "#64748b");
      }
      
      // Helper function to find significant peaks
      function findSignificantPeak(data, thresholdFactor = 0.5) {
        if (!data || data.length < 10) return null;
        
        const baseline = calculateBaseline(data);
        const threshold = baseline + (baseline * thresholdFactor);
        
        let maxIndex = -1;
        let maxValue = threshold;
        
        // Find the highest peak after the first 10 points
        for (let i = 10; i < data.length / 2; i++) {
          if (data[i].value > maxValue) {
            maxValue = data[i].value;
            maxIndex = i;
          }
        }
        
        if (maxIndex === -1) return null;
        
        return {
          index: maxIndex,
          time: data[maxIndex].relativeTime,
          value: maxValue
        };
      }
      
      // Helper function to find recovery period after a peak
      function findRecoveryPeriod(data, peakIndex) {
        if (!data || peakIndex >= data.length - 1) return null;
        
        const peakValue = data[peakIndex].value;
        const baseline = calculateBaseline(data);
        const recoveryThreshold = baseline + ((peakValue - baseline) * 0.3); // Recovered to 30% of spike
        
        let recoveryIndex = -1;
        
        // Find the point where value drops below recovery threshold
        for (let i = peakIndex + 1; i < data.length; i++) {
          if (data[i].value <= recoveryThreshold) {
            recoveryIndex = i;
            break;
          }
        }
        
        if (recoveryIndex === -1) return null;
        
        return {
          endIndex: recoveryIndex,
          time: data[recoveryIndex].relativeTime,
          value: data[recoveryIndex].value,
          duration: data[recoveryIndex].relativeTime - data[peakIndex].relativeTime
        };
      }
      
      // Helper function to calculate baseline (average of first 10% of data)
      function calculateBaseline(data) {
        if (!data || data.length === 0) return 0;
        
        const numBaselinePoints = Math.max(5, Math.floor(data.length * 0.1));
        let sum = 0;
        
        for (let i = 0; i < numBaselinePoints; i++) {
          sum += data[i].value;
        }
        
        return sum / numBaselinePoints;
      }
      
      // Helper function to calculate variance (amplitude of fluctuations)
      function calculateVariance(data) {
        if (!data || data.length < 5) return 0;
        
        const mean = data.reduce((sum, d) => sum + d.value, 0) / data.length;
        const squaredDiffs = data.map(d => Math.pow(d.value - mean, 2));
        return squaredDiffs.reduce((sum, val) => sum + val, 0) / data.length;
      }
      
      // Add arrow marker definition
      svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 8)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#111");
      
      // Initialize scrollama
      const scroller = scrollama();
      
      scroller.setup({
        step: ".step",
        offset: 0.5,
        debug: false
      })
      .onStepEnter(response => {
        // Set active step styling
        d3.selectAll(".step").classed("is-active", false);
        d3.select(response.element).classed("is-active", true);
        
        // Update chart
        const stepIndex = response.index;
        currentStep = stepIndex;
        updateChart(stepIndex, {
          midterm1: midterm1Data ? calculateAveragePattern(midterm1Data) : [],
          midterm2: midterm2Data ? calculateAveragePattern(midterm2Data) : [],
          final: finalData ? calculateAveragePattern(finalData) : []
        });
      });
      
      // Resize event handler
      function handleResize() {
        scroller.resize();
      }
      
      // Update on resize
      window.addEventListener("resize", handleResize);
      
      // Add event listeners to toggle buttons
      document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          handleMetricToggle(btn.dataset.metric);
        });
      });
      
      // Initialize with default metric (EDA)
      loadData(currentMetric);

      function detectAllSpikes(data, thresholdFactor = 0.3) {
  if (!data || data.length < 10) return [];
  
  const baseline = calculateBaseline(data);
  const threshold = baseline + (baseline * thresholdFactor);
  
  const spikes = [];
  let inSpike = false;
  let spikeStart = 0;
  let spikePeak = 0;
  let spikePeakIndex = 0;
  
  for (let i = 1; i < data.length; i++) {
    if (!inSpike && data[i].value > threshold) {
      inSpike = true;
      spikeStart = i;
      spikePeak = data[i].value;
      spikePeakIndex = i;
    } else if (inSpike) {
      if (data[i].value > spikePeak) {
        spikePeak = data[i].value;
        spikePeakIndex = i;
      } else if (data[i].value < threshold) {
        spikes.push({
          startIndex: spikeStart,
          peakIndex: spikePeakIndex,
          endIndex: i,
          startTime: data[spikeStart].relativeTime,
          peakTime: data[spikePeakIndex].relativeTime,
          endTime: data[i].relativeTime,
          value: spikePeak,
          duration: data[i].relativeTime - data[spikeStart].relativeTime
        });
        
        inSpike = false;
      }
    }
  }
  
  return spikes;
}

// Helper function to calculate average recovery time
function averageRecoveryTime(data) {
  const spikes = detectAllSpikes(data);
  if (spikes.length === 0) return 0;
  
  const recoveryTimes = spikes.map(spike => spike.endTime - spike.peakTime);
  return recoveryTimes.reduce((sum, time) => sum + time, 0) / recoveryTimes.length;
}

// Helper function to find peak timings
function findPeakTimings(data) {
  const spikes = detectAllSpikes(data);
  if (spikes.length < 2) return { avgSpacing: 0, variability: 0 };
  
  const peakTimes = spikes.map(spike => spike.peakTime);
  const spacings = [];
  
  for (let i = 1; i < peakTimes.length; i++) {
    spacings.push(peakTimes[i] - peakTimes[i-1]);
  }
  
  const avgSpacing = spacings.reduce((sum, spacing) => sum + spacing, 0) / spacings.length;
  const spacingVariances = spacings.map(spacing => Math.pow(spacing - avgSpacing, 2));
  const variability = Math.sqrt(spacingVariances.reduce((sum, variance) => sum + variance, 0) / spacingVariances.length);
  
  return { avgSpacing, variability };
}

// Helper function to estimate settling time
function estimateSettlingTime(data) {
  if (!data || data.length < 20) return 0;
  
  const baseline = calculateBaseline(data);
  const thresholdHigh = baseline * 1.1; // 10% above baseline
  const thresholdLow = baseline * 0.9;  // 10% below baseline
  
  let settlingIndex = 0;
  let settled = false;
  
  // Find when the values stay within 10% of baseline for at least 10 consecutive points
  for (let i = 10; i < data.length - 10; i++) {
    let isSettled = true;
    
    // Check 10 consecutive points
    for (let j = 0; j < 10; j++) {
      const val = data[i + j].value;
      if (val > thresholdHigh || val < thresholdLow) {
        isSettled = false;
        break;
      }
    }
    
    if (isSettled) {
      settlingIndex = i;
      settled = true;
      break;
    }
  }
  
  return settled ? data[settlingIndex].relativeTime : data[Math.floor(data.length * 0.2)].relativeTime;
}

// Helper function to get appropriate range text based on metric
function getUnitRangeText(metric, min, max) {
  min = parseFloat(min.toFixed(2));
  max = parseFloat(max.toFixed(2));
  
  switch(metric) {
    case "EDA":
      return `${min} and ${max} microsiemens (Î¼S)`;
    case "HR":
      return `${min} and ${max} beats per minute (BPM)`;
    case "TEMP":
      return `${min}Â°C and ${max}Â°C`;
    default:
      return `${min} and ${max}`;
  }
}

// Helper function to analyze student patterns
function analyzeStudentPatterns(studentIds) {
  // This would ideally use real student data
  // We'll simulate based on our existing averages
  
  // High performers (S1, S3) generally have:
  // - Faster recovery times
  // - Lower peak-to-baseline ratios
  // Low performers (S7, S9) show the opposite
  
  let avgRecovery, peakToBaseline;
  
  if (studentIds.includes("S1") || studentIds.includes("S3")) {
    // High performers
    switch(currentMetric) {
      case "EDA":
        avgRecovery = 12.5;
        peakToBaseline = 1.8;
        break;
      case "HR":
        avgRecovery = 18.2;
        peakToBaseline = 1.4;
        break;
      case "TEMP":
        avgRecovery = 65.0;
        peakToBaseline = 1.05;
        break;
      default:
        avgRecovery = 15.0;
        peakToBaseline = 1.5;
    }
  } else {
    // Low performers
    switch(currentMetric) {
      case "EDA":
        avgRecovery = 28.7;
        peakToBaseline = 2.6;
        break;
      case "HR":
        avgRecovery = 42.5;
        peakToBaseline = 1.9;
        break;
      case "TEMP":
        avgRecovery = 152.0;
        peakToBaseline = 1.12;
        break;
      default:
        avgRecovery = 35.0;
        peakToBaseline = 2.2;
    }
  }
  
  return { avgRecovery, peakToBaseline };
}

// Functions to update text content for each step
function updateStepZeroText(results) {
  // Update step 0 text based on data analysis
  const mainText = document.querySelector(`.step[data-step="0"] p:first-of-type`);
  const highlightContent = document.querySelector(`.step[data-step="0"] .highlight-content-${currentMetric}`);
  const statDescription = document.querySelector(`.step[data-step="0"] .stat-description-${currentMetric}`);
  const closingText = document.querySelector(`.step[data-step="0"] p:last-of-type`);
  
  // Create dynamic texts based on the actual data
  const units = currentMetric === "EDA" ? "Î¼S" : (currentMetric === "HR" ? "BPM" : "Â°C");
  
  mainText.textContent = `
    The first midterm establishes our baseline for ${currentMetric} measurements. The data shows 
    students typically maintain a baseline of ${results.baseline} ${units}, with 
    ${results.spikeCount} distinct spikes occurring when encountering challenging questions.
  `;
  
  highlightContent.textContent = `
    During the first midterm, students' ${currentMetric} levels typically range between ${results.rangeText}
    with an average of ${results.avgValue} ${units}.
  `;
  
  // Update the stat and description
  document.querySelector(`.step[data-step="0"] .stat`).textContent = `${results.settlingTime}s`;
  statDescription.textContent = `average time for students' ${currentMetric} to stabilize after beginning the exam`;
  
  closingText.textContent = `
    The data reveals a clear wave-like pattern, with an average variation of Â±${results.stdDev} ${units},
    representing the ebb and flow of physiological responses as students tackle questions of varying difficulty.
  `;
}

function updateStepOneText(results) {
  // Update step 1 text based on comparison data
  const mainText = document.querySelector(`.step[data-step="1"] p:first-of-type`);
  const highlightContent = document.querySelector(`.step[data-step="1"] .highlight-content-${currentMetric}`);
  const closingText = document.querySelector(`.step[data-step="1"] p:last-of-type`);
  
  const baselineChangeText = results.baselineHigher ? 
    `${results.baselineDiff}% higher` : 
    `${Math.abs(results.baselineDiff)}% lower`;
  
  const units = currentMetric === "EDA" ? "Î¼S" : (currentMetric === "HR" ? "BPM" : "Â°C");
  
  mainText.textContent = `
    By the second midterm, students show ${results.fasterRecovery ? "more controlled" : "different"} ${currentMetric} responses. 
    Their baseline level is ${baselineChangeText} (${results.m2Baseline} ${units} vs. ${results.m1Baseline} ${units}),
    suggesting their bodies have adapted to the testing environment.
  `;
  
  highlightContent.textContent = `
    The data shows ${results.recoveryImprovement !== "N/A" ? 
      `a ${results.recoveryImprovement}% improvement in recovery time` : 
      "changes in recovery patterns"}, with students returning to baseline in 
    ${results.m2Recovery} seconds versus ${results.m1Recovery} seconds in the first midterm.
  `;
  
  closingText.textContent = `
    The highlighted areas show ${currentMetric} peaks, which are ${results.fasterRecovery ? 
      "shorter in duration but sometimes more intense" : 
      "changing in both duration and intensity"} as students develop 
    familiarity with the testing format.
  `;
}

function updateStepTwoText(results) {
  // Update step 2 text based on final exam comparison
  const mainText = document.querySelector(`.step[data-step="2"] p:first-of-type`);
  const secondaryText = document.querySelector(`.step[data-step="2"] p:nth-of-type(2)`);
  const highlightContent = document.querySelector(`.step[data-step="2"] .highlight-content-${currentMetric}`);
  const statDescription = document.querySelector(`.step[data-step="2"] .stat-description-${currentMetric}`);
  
  const units = currentMetric === "EDA" ? "Î¼S" : (currentMetric === "HR" ? "BPM" : "Â°C");
  const baselineChangeText = `${results.baselineDiff}% ${parseInt(results.baselineDiff) > 0 ? "higher" : "lower"}`;
  
  mainText.textContent = `
    The final exam data reveals a fascinating pattern: the baseline ${currentMetric} is ${baselineChangeText}
    (${results.finalBaseline} ${units} compared to ${results.m2Baseline} ${units} in midterm 2),
    reflecting the higher-stakes environment.
  `;
  
  secondaryText.textContent = `
    Yet interestingly, despite this elevated baseline, the data shows ${results.improvedRegulation ? 
      "more controlled responses to individual questions" : 
      "changes in how students respond to individual questions"}, suggesting the development of 
    adaptive stress management strategies throughout the semester.
  `;
  
  highlightContent.textContent = `
    The maximum ${currentMetric} peaks during finals are ${results.peakHigher ? 
      `${results.peakDiff}% higher (${results.finalMaxPeak} ${units})` : 
      `${Math.abs(results.peakDiff)}% lower (${results.finalMaxPeak} ${units})`} 
    than during midterm 2 (${results.m2MaxPeak} ${units}), ${results.peakHigher ? 
      "despite" : "consistent with"} students' self-reported anxiety levels.
  `;
  
  // Update the stat description
  statDescription.textContent = `faster ${currentMetric} recovery for A students vs. C students during finals`;
}

function updateStepThreeText(results) {
  // Update step 3 text based on individual student analysis
  const mainText = document.querySelector(`.step[data-step="3"] p:first-of-type`);
  const secondaryText = document.querySelector(`.step[data-step="3"] p:nth-of-type(2)`);
  const highlightContent = document.querySelector(`.step[data-step="3"] .highlight-content-${currentMetric}`);
  
  const units = currentMetric === "EDA" ? "Î¼S" : (currentMetric === "HR" ? "BPM" : "Â°C");
  
  mainText.textContent = `
    Our data reveals significant differences in ${currentMetric} regulation between high and low-performing students.
    The individual patterns show that physiological regulation capability varies dramatically between students.
  `;
  
  secondaryText.textContent = `
    High performers (Students 1 and 3) show an average recovery time of ${results.highPerformerAvgRecovery} seconds,
    compared to ${results.lowPerformerAvgRecovery} seconds for lower performers (Students 7 and 9) - 
    a ${results.recoveryDiff}Ã difference in recovery speed.
  `;
  
  highlightContent.textContent = `
    High-performing students maintain peak-to-baseline ratios of ${results.highPeakBaseline}Ã, while
    lower-performing students reach ${results.lowPeakBaseline}Ã their baseline during stressful moments.
    This suggests that ${currentMetric} control, not just lower absolute levels, correlates with performance.
  `;
}

function updateStepFourText(results) {
  // Update step 4 text based on evolution analysis
  const mainText = document.querySelector(`.step[data-step="4"] p:first-of-type`);
  const secondaryText = document.querySelector(`.step[data-step="4"] p:nth-of-type(2)`);
  const highlightContent = document.querySelector(`.step[data-step="4"] .highlight-content-${currentMetric}`);
  
  const units = currentMetric === "EDA" ? "Î¼S" : (currentMetric === "HR" ? "BPM" : "Â°C");
  
  let trendText;
  if (results.varianceTrend === "decreasing") {
    trendText = `decreasing variability (${results.m1Variance} â ${results.m2Variance} â ${results.finalVariance})`;
  } else if (results.varianceTrend === "increasing") {
    trendText = `increasing variability (${results.m1Variance} â ${results.m2Variance} â ${results.finalVariance})`;
  } else {
    trendText = `mixed variability patterns (${results.m1Variance} â ${results.m2Variance} â ${results.finalVariance})`;
  }
  
  mainText.textContent = `
    When we overlay ${currentMetric} data from all three exams, a clear evolution emerges. The baseline
    changes from ${results.m1Baseline} to ${results.m2Baseline} to ${results.finalBaseline} ${units},
    while students develop more efficient regulation strategies.
  `;
  
  secondaryText.textContent = `
    The data shows ${trendText}, indicating ${results.varianceTrend === "decreasing" ? 
    "improved emotional regulation" : 
    results.varianceTrend === "increasing" ? 
    "heightened reactivity" : 
    "complex adaptation patterns"} as students progress through the semester.
  `;
  
  highlightContent.textContent = `
    This ${currentMetric} evolution demonstrates what psychologists call adaptive stress responseâ
    from midterm 1 to midterm 2, variability changed by ${results.varianceM1toM2}%, while from
    midterm 2 to final, it changed by ${results.varianceM2toFinal}%, showing the body's 
    ability to calibrate its physiological reaction to match the appropriate challenge level.
  `;
}

// Main dynamic narration function that analyzes data and updates UI
function updateDynamicNarration(step, avgData) {
  // Get data for analysis
  const m1Data = avgData.midterm1;
  const m2Data = avgData.midterm2;
  const finalData = avgData.final;
  
  // Initialize variables to store analysis results
  let analysisResults = {};
  
  // Perform data analysis based on the step and metric
  if (step === 0 && m1Data && m1Data.length > 0) {
    // Step 0: Midterm 1 Analysis
    const baseline = calculateBaseline(m1Data);
    const maxValue = d3.max(m1Data, d => d.value);
    const minValue = d3.min(m1Data, d => d.value);
    const avgValue = m1Data.reduce((sum, d) => sum + d.value, 0) / m1Data.length;
    const stdDev = Math.sqrt(calculateVariance(m1Data));
    const spikes = detectAllSpikes(m1Data);
    const rangeText = getUnitRangeText(currentMetric, minValue, maxValue);
    
    analysisResults = {
      baseline: baseline.toFixed(2),
      maxValue: maxValue.toFixed(2),
      minValue: minValue.toFixed(2),
      avgValue: avgValue.toFixed(2),
      stdDev: stdDev.toFixed(2),
      spikeCount: spikes.length,
      rangeText: rangeText,
      settlingTime: estimateSettlingTime(m1Data)
    };
    
    // Update text content
    updateStepZeroText(analysisResults);
    
  } else if (step === 1 && m1Data && m2Data && m1Data.length > 0 && m2Data.length > 0) {
    // Step 1: Comparing Midterm 1 and 2
    const m1Baseline = calculateBaseline(m1Data);
    const m2Baseline = calculateBaseline(m2Data);
    const m1Recovery = averageRecoveryTime(m1Data);
    const m2Recovery = averageRecoveryTime(m2Data);
    const recoveryImprovement = m1Recovery > 0 && m2Recovery > 0 ? 
      ((m1Recovery - m2Recovery) / m1Recovery * 100).toFixed(0) : "N/A";
    
    analysisResults = {
      m1Baseline: m1Baseline.toFixed(2),
      m2Baseline: m2Baseline.toFixed(2),
      baselineDiff: ((m2Baseline - m1Baseline) / m1Baseline * 100).toFixed(0),
      baselineHigher: m2Baseline > m1Baseline,
      m1Recovery: m1Recovery.toFixed(1),
      m2Recovery: m2Recovery.toFixed(1),
      recoveryImprovement: recoveryImprovement,
      fasterRecovery: m2Recovery < m1Recovery
    };
    
    // Update text content
    updateStepOneText(analysisResults);
    
  } else if (step === 2 && m2Data && finalData && m2Data.length > 0 && finalData.length > 0) {
    // Step 2: Final exam analysis
    const m2Baseline = calculateBaseline(m2Data);
    const finalBaseline = calculateBaseline(finalData);
    const m2MaxPeak = d3.max(m2Data, d => d.value);
    const finalMaxPeak = d3.max(finalData, d => d.value);
    const m2PeakTiming = findPeakTimings(m2Data);
    const finalPeakTiming = findPeakTimings(finalData);
    
    analysisResults = {
      m2Baseline: m2Baseline.toFixed(2),
      finalBaseline: finalBaseline.toFixed(2),
      baselineDiff: ((finalBaseline - m2Baseline) / m2Baseline * 100).toFixed(0),
      m2MaxPeak: m2MaxPeak.toFixed(2),
      finalMaxPeak: finalMaxPeak.toFixed(2),
      peakDiff: ((finalMaxPeak - m2MaxPeak) / m2MaxPeak * 100).toFixed(0),
      peakHigher: finalMaxPeak > m2MaxPeak,
      improvedRegulation: finalPeakTiming.variability < m2PeakTiming.variability
    };
    
    // Update text content
    updateStepTwoText(analysisResults);
    
  } else if (step === 3) {
    // Step 3: Individual student data
    // This depends on student-specific data, which we'll simulate
    const highPerformerPattern = analyzeStudentPatterns(["S1", "S3"]);
    const lowPerformerPattern = analyzeStudentPatterns(["S7", "S9"]);
    
    analysisResults = {
      highPerformerAvgRecovery: highPerformerPattern.avgRecovery.toFixed(1),
      lowPerformerAvgRecovery: lowPerformerPattern.avgRecovery.toFixed(1),
      recoveryDiff: (highPerformerPattern.avgRecovery > 0 && lowPerformerPattern.avgRecovery > 0) ? 
        (lowPerformerPattern.avgRecovery / highPerformerPattern.avgRecovery).toFixed(1) : "N/A",
      highPeakBaseline: highPerformerPattern.peakToBaseline.toFixed(1),
      lowPeakBaseline: lowPerformerPattern.peakToBaseline.toFixed(1)
    };
    
    // Update text content
    updateStepThreeText(analysisResults);
    
  } else if (step === 4 && m1Data && m2Data && finalData) {
    // Step 4: Evolution across all exams
    const m1Variance = calculateVariance(m1Data);
    const m2Variance = calculateVariance(m2Data);
    const finalVariance = calculateVariance(finalData);
    
    const m1Baseline = calculateBaseline(m1Data);
    const m2Baseline = calculateBaseline(m2Data);
    const finalBaseline = calculateBaseline(finalData);
    
    analysisResults = {
      m1Variance: m1Variance.toFixed(3),
      m2Variance: m2Variance.toFixed(3),
      finalVariance: finalVariance.toFixed(3),
      varianceTrend: m1Variance > m2Variance && m2Variance > finalVariance ? "decreasing" : 
                    (m1Variance < m2Variance && m2Variance < finalVariance ? "increasing" : "mixed"),
      varianceM1toM2: ((m2Variance - m1Variance) / m1Variance * 100).toFixed(0),
      varianceM2toFinal: ((finalVariance - m2Variance) / m2Variance * 100).toFixed(0),
      m1Baseline: m1Baseline.toFixed(2),
      m2Baseline: m2Baseline.toFixed(2),
      finalBaseline: finalBaseline.toFixed(2)
    };
    
    // Update text content
    updateStepFourText(analysisResults);
  }
}

// Function to create simulated data if real data can't be loaded
function createSimulatedData(metric) {
  const createDataSeries = (baseValue, variability, peakCount) => {
    const data = {};
    const studentIds = ["S1", "S2", "S3", "S7", "S9"];
    
    studentIds.forEach(id => {
      const points = [];
      const duration = 3600; // 60 minutes in seconds
      const interval = 5; // 5 seconds between points
      
      for (let time = 0; time < duration; time += interval) {
        // Base value depends on metric
        let value = baseValue;
        
        // Add randomness
        value += (Math.random() - 0.5) * variability;
        
        // Add occasional peaks
        if (Math.random() < 0.02) { // 2% chance of a peak
          value += variability * 2 * Math.random();
        }
        
        // Ensure value is positive
        value = Math.max(0.01, value);
        
        points.push({
          relativeTime: time,
          value: value,
          timestamp: Date.now() + time * 1000 // Dummy timestamp
        });
      }
      
      data[id] = {
        points: points,
        stressEvents: [] // We'll leave this empty for simplicity
      };
    });
    
    return data;
  };
  
  // Configure based on metric
  let baseValue, variability;
  
  switch (metric) {
    case "EDA":
      baseValue = 0.05;
      variability = 0.03;
      break;
    case "HR":
      baseValue = 75;
      variability = 10;
      break;
    case "TEMP":
      baseValue = 37;
      variability = 0.3;
      break;
    default:
      baseValue = 1;
      variability = 0.2;
  }
  
  return {
    midterm1: createDataSeries(baseValue, variability, 5),
    midterm2: createDataSeries(baseValue * 0.9, variability * 0.8, 4), // Slightly lower baseline, less variable
    final: createDataSeries(baseValue * 1.1, variability * 0.7, 3) // Higher baseline, even less variable
  };
}
    })();

    
  </script>
</body>
</html>